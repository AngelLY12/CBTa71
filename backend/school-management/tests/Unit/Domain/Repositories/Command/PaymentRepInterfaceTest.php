<?php

namespace Tests\Unit\Domain\Repositories\Command;

use Tests\Stubs\Repositories\Command\PaymentRepStub;
use Tests\Unit\Domain\Repositories\BaseRepositoryTestCase;
use App\Core\Domain\Repositories\Command\Payments\PaymentRepInterface;
use App\Core\Domain\Entities\Payment;
use App\Core\Domain\Enum\Payment\PaymentStatus;
use Carbon\Carbon;
use PHPUnit\Framework\Attributes\Test;
use Illuminate\Database\Eloquent\ModelNotFoundException;

class PaymentRepInterfaceTest extends BaseRepositoryTestCase
{
    /**
     * The interface class being implemented
     */
    protected string $interfaceClass = PaymentRepInterface::class;

    /**
     * Setup the repository instance for testing
     */
    protected function setUp(): void
    {
        parent::setUp();

        // Usamos un stub para probar el contrato
        $this->repository = new PaymentRepStub();
    }

    /**
     * Test que el repositorio puede ser instanciado
     */
    #[Test]
    public function it_can_be_instantiated(): void
    {
        $this->assertNotNull($this->repository, 'El repositorio no está inicializado');
        $this->assertImplementsInterface($this->interfaceClass);
    }

    /**
     * Test que todos los métodos requeridos existen
     */
    #[Test]
    public function it_has_all_required_methods(): void
    {
        $this->assertNotNull($this->repository, 'El repositorio no está inicializado');

        $methods = [
            'create',
            'update',
            'delete'
        ];

        foreach ($methods as $method) {
            $this->assertMethodExists($method);
        }
    }

    #[Test]
    public function it_can_create_payment(): void
    {
        $payment = new Payment(
            concept_name: 'Matrícula Semestral',
            amount: '5000.00',
            status: PaymentStatus::DEFAULT,
            payment_method_details: ['Tarjeta de crédito'],
            user_id: 1,
            payment_concept_id: 10,
            stripe_session_id: 'cs_test_123'
        );

        $result = $this->repository->create($payment);

        $this->assertInstanceOf(Payment::class, $result);
        $this->assertEquals('Matrícula Semestral', $result->concept_name);
        $this->assertEquals('5000.00', $result->amount);
        $this->assertEquals(PaymentStatus::DEFAULT, $result->status);
        $this->assertEquals(1, $result->user_id);
        $this->assertNotNull($result->id);
        $this->assertNotNull($result->created_at);
    }

    #[Test]
    public function created_payment_has_autogenerated_id_and_timestamp(): void
    {
        $payment = new Payment(
            concept_name: 'Inscripción',
            amount: '2000.00',
            status: PaymentStatus::DEFAULT
        );

        $result = $this->repository->create($payment);

        $this->assertNotNull($result->id);
        $this->assertGreaterThan(0, $result->id);
        $this->assertInstanceOf(Carbon::class, $result->created_at);
    }

    #[Test]
    public function it_can_update_payment(): void
    {
        // Primero crear un pago
        $payment = new Payment(
            concept_name: 'Pago original',
            amount: '1000.00',
            status: PaymentStatus::DEFAULT,
            user_id: 2
        );
        $created = $this->repository->create($payment);

        // Actualizar el pago
        $fields = [
            'status' => PaymentStatus::PAID,
            'amount_received' => '1000.00',
            'payment_intent_id' => 'pi_123456'
        ];

        $result = $this->repository->update($created->id, $fields);

        $this->assertInstanceOf(Payment::class, $result);
        $this->assertEquals($created->id, $result->id);
        $this->assertEquals(PaymentStatus::PAID, $result->status);
        $this->assertEquals('1000.00', $result->amount_received);
        $this->assertEquals('pi_123456', $result->payment_intent_id);
    }

    #[Test]
    public function update_throws_exception_when_payment_not_found(): void
    {
        $paymentId = 999;
        $fields = ['status' => PaymentStatus::PAID];

        $this->expectException(ModelNotFoundException::class);

        $this->repository->update($paymentId, $fields);
    }

    #[Test]
    public function it_can_delete_payment(): void
    {
        // Primero crear un pago
        $payment = new Payment(
            concept_name: 'Pago a eliminar',
            amount: '3000.00',
            status: PaymentStatus::DEFAULT,
            user_id: 3
        );
        $created = $this->repository->create($payment);

        // Eliminar el pago
        $this->repository->delete($created->id);

        // Verificar que ya no existe
        $stub = $this->repository;
        $this->expectException(ModelNotFoundException::class);

        $stub->update($created->id, ['status' => PaymentStatus::PAID]);
    }

    #[Test]
    public function delete_throws_exception_when_payment_not_found(): void
    {
        $paymentId = 999;

        $this->expectException(ModelNotFoundException::class);

        $this->repository->delete($paymentId);
    }

    #[Test]
    public function payment_can_be_overpaid(): void
    {
        $payment = new Payment(
            concept_name: 'Pago excedente',
            amount: '1000.00',
            status: PaymentStatus::OVERPAID,
            amount_received: '1200.00'
        );

        $this->assertTrue($payment->isOverPaid());
        $this->assertFalse($payment->isUnderPaid());
        $this->assertEquals('200.00', $payment->getOverPaidAmount());
        $this->assertEquals('0.00', $payment->getPendingAmount());
    }

    #[Test]
    public function payment_can_be_underpaid(): void
    {
        $payment = new Payment(
            concept_name: 'Pago incompleto',
            amount: '1000.00',
            status: PaymentStatus::UNDERPAID,
            amount_received: '800.00'
        );

        $this->assertTrue($payment->isUnderPaid());
        $this->assertFalse($payment->isOverPaid());
        $this->assertEquals('200.00', $payment->getPendingAmount());
        $this->assertEquals('0.00', $payment->getOverPaidAmount());
    }

    #[Test]
    public function payment_can_be_non_paid(): void
    {
        $payment = new Payment(
            concept_name: 'Pago pendiente',
            amount: '1000.00',
            status: PaymentStatus::UNPAID
        );

        $this->assertTrue($payment->isNonPaid());
        $this->assertEquals('1000.00', $payment->getPendingAmount());
        $this->assertEquals('0.00', $payment->getOverPaidAmount());
    }

    #[Test]
    public function payment_can_be_recent(): void
    {
        $payment = new Payment(
            concept_name: 'Pago reciente',
            amount: '1000.00',
            status: PaymentStatus::PAID,
            created_at: Carbon::now()->subMinutes(30) // Hace 30 minutos
        );

        $this->assertTrue($payment->isRecentPayment());
    }

    #[Test]
    public function payment_can_be_old(): void
    {
        $payment = new Payment(
            concept_name: 'Pago antiguo',
            amount: '1000.00',
            status: PaymentStatus::PAID,
            created_at: Carbon::now()->subHours(2) // Hace 2 horas
        );

        $this->assertFalse($payment->isRecentPayment());
    }

    #[Test]
    public function payment_amount_calculations(): void
    {
        $payment = new Payment(
            concept_name: 'Cálculos',
            amount: '1500.50',
            status: PaymentStatus::UNDERPAID,
            amount_received: '1000.25'
        );

        $this->assertEquals('500.25', $payment->getPendingAmount());
        $this->assertEquals('0.00', $payment->getOverPaidAmount());
    }

    #[Test]
    public function payment_without_amount_received(): void
    {
        $payment = new Payment(
            concept_name: 'Sin monto recibido',
            amount: '1000.00',
            status: PaymentStatus::DEFAULT
        );

        $this->assertEquals('1000.00', $payment->getPendingAmount());
        $this->assertEquals('0.00', $payment->getOverPaidAmount());
    }

    #[Test]
    public function it_handles_database_errors_gracefully(): void
    {
        $stub = new PaymentRepStub();
        $stub->shouldThrowDatabaseError(true);

        $payment = new Payment(
            concept_name: 'Pago con error',
            amount: '1000.00',
            status: PaymentStatus::DEFAULT
        );

        $this->expectException(\RuntimeException::class);
        $this->expectExceptionMessage('Database error');

        $stub->create($payment);
    }

    #[Test]
    public function it_can_handle_multiple_operations(): void
    {
        $stub = new PaymentRepStub();

        // 1. Crear pago
        $payment1 = $stub->create(new Payment('Pago 1', '1000.00', PaymentStatus::DEFAULT, [], null, 1));
        $this->assertNotNull($payment1->id);

        // 2. Crear otro pago
        $payment2 = $stub->create(new Payment('Pago 2', '2000.00', PaymentStatus::DEFAULT, [], null, 1));
        $this->assertNotNull($payment2->id);
        $this->assertNotEquals($payment1->id, $payment2->id);

        // 3. Actualizar el primero
        $updated = $stub->update($payment1->id, ['status' => PaymentStatus::PAID, 'amount_received' => '1000.00']);
        $this->assertEquals(PaymentStatus::PAID, $updated->status);

        // 4. Eliminar el segundo
        $stub->delete($payment2->id);

        // 5. Verificar que el segundo ya no existe
        $this->expectException(ModelNotFoundException::class);
        $stub->update($payment2->id, ['status' => PaymentStatus::PAID]);
    }

    #[Test]
    public function payment_status_enum_methods(): void
    {
        $this->assertTrue(in_array('paid', PaymentStatus::paidStatuses()));
        $this->assertTrue(in_array('pending', PaymentStatus::nonTerminalStatuses()));

        $nonPaidStatuses = array_map(fn($status) => $status->value, PaymentStatus::nonPaidStatuses());
        $this->assertContains('pending', $nonPaidStatuses);
        $this->assertContains('unpaid', $nonPaidStatuses);

        $reconciliableStatus = array_map(fn($status) => $status->value, PaymentStatus::reconcilableStatuses());
        $this->assertContains('pending', $reconciliableStatus);
        $this->assertContains('paid', $reconciliableStatus);
    }
}

