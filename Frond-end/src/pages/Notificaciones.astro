---
import Layout from '../layouts/Layout.astro';

const pageTitle = "Notificaciones";
---

<Layout title={pageTitle}>
  <div class="max-w-6xl mx-auto px-4 sm:px-5 lg:px-6 overflow-x-hidden">
    <!-- Header -->
    <div class="flex flex-col sm:flex-row justify-between items-start sm:items-center gap-4 mb-8">
      <div class="min-w-0 w-full">
        <h1 class="text-3xl sm:text-4xl font-black text-[#2e594d] mb-2 flex items-center gap-2 sm:gap-3 leading-tight min-w-0">
          <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8 sm:h-10 sm:w-10 text-[#86efad] shrink-0" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
            <path stroke-linecap="round" stroke-linejoin="round" d="M15 17h5l-1.405-1.405A2.032 2.032 0 0118 14.158V11a6 6 0 00-5-5.917V4a1 1 0 10-2 0v1.083A6 6 0 006 11v3.159c0 .538-.214 1.055-.595 1.436L4 17h5m6 0v1a3 3 0 11-6 0v-1m6 0H9" />
          </svg>
          <span class="break-words">Notificaciones</span>
        </h1>
        <p class="text-gray-600 text-sm flex items-start gap-2 min-w-0">
          <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 shrink-0 mt-0.5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
          </svg>
          <span class="break-words">Mantente al tanto de tus avisos y actualizaciones importantes</span>
        </p>
      </div>
      
      <button id="mark-all-read-btn" class="w-full sm:w-auto px-4 sm:px-6 py-3 bg-[#2e594d] hover:bg-[#86efad] hover:text-[#2e594d] text-white rounded-xl font-bold text-sm transition-all shadow-lg hover:shadow-xl flex items-center justify-center gap-2 whitespace-nowrap">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7" />
        </svg>
        Marcar todas como leÃ­das
      </button>
    </div>

    <!-- Filtros de notificaciones -->
    <div class="mb-6 flex flex-wrap gap-2 sm:gap-3">
      <button class="filter-btn active px-4 sm:px-5 py-2 rounded-full font-bold text-sm transition-all" data-filter="all">
        Todas
      </button>
      <button class="filter-btn px-4 sm:px-5 py-2 rounded-full font-bold text-sm transition-all" data-filter="payment">
        ðŸ’° Pagos
      </button>
      <button class="filter-btn px-4 sm:px-5 py-2 rounded-full font-bold text-sm transition-all" data-filter="academic">
        ðŸ“š AcadÃ©micas
      </button>
      <button class="filter-btn px-4 sm:px-5 py-2 rounded-full font-bold text-sm transition-all" data-filter="administrative">
        ðŸ“‹ Administrativas
      </button>
      <button class="filter-btn px-4 sm:px-5 py-2 rounded-full font-bold text-sm transition-all" data-filter="general">
        ðŸ“¢ Generales
      </button>
    </div>

    <!-- Lista de notificaciones -->
    <div id="notifications-container" class="space-y-4">
      <!-- Las notificaciones se cargarÃ¡n dinÃ¡micamente aquÃ­ -->
    </div>

    <!-- Mensaje cuando no hay notificaciones -->
    <div id="no-notifications" class="hidden text-center py-20">
      <svg xmlns="http://www.w3.org/2000/svg" class="h-24 w-24 mx-auto text-gray-300 mb-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20 13V6a2 2 0 00-2-2H6a2 2 0 00-2 2v7m16 0v5a2 2 0 01-2 2H6a2 2 0 01-2-2v-5m16 0h-2.586a1 1 0 00-.707.293l-2.414 2.414a1 1 0 01-.707.293h-3.172a1 1 0 01-.707-.293l-2.414-2.414A1 1 0 006.586 13H4" />
      </svg>
      <h3 class="text-2xl font-bold text-gray-400 mb-2">No tienes notificaciones</h3>
      <p class="text-gray-500">Â¡EstÃ¡s al dÃ­a con todo!</p>
    </div>
  </div>

  <script>
    // @ts-nocheck
    const API_BASE = `${(import.meta.env.PUBLIC_API_BASE_URL ?? (() => { throw new Error('Falta PUBLIC_API_BASE_URL'); })()).replace(/\/$/, '')}/v1`;
    let allNotifications = [];
    let currentFilter = 'all';
    let currentPage = 1;
    const perPage = 20;

    // Obtener token
    function getToken() {
      return localStorage.getItem('access_token');
    }

    // Fetch notificaciones desde la API
    async function fetchNotifications() {
      const token = getToken();
      if (!token) {
        console.error('No hay token de autenticaciÃ³n');
        showNoNotifications();
        return;
      }

      try {
        // Obtener notificaciones leÃ­das
        const readResponse = await fetch(`${API_BASE}/notifications?page=${currentPage}&per_page=${perPage}`, {
          headers: {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json'
          }
        });

        // Obtener notificaciones no leÃ­das
        const unreadResponse = await fetch(`${API_BASE}/notifications/unread?page=1&per_page=50`, {
          headers: {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json'
          }
        });

        if (readResponse.ok && unreadResponse.ok) {
          const readData = await readResponse.json();
          const unreadData = await unreadResponse.json();

          console.log('âœ… Notificaciones leÃ­das:', readData);
          console.log('âœ… Notificaciones no leÃ­das:', unreadData);

          // Combinar notificaciones
          const readNotifications = readData.data?.notifications?.data || [];
          const unreadNotifications = unreadData.data?.notifications || [];

          allNotifications = [
            ...unreadNotifications.map(n => normalizeNotification(n, false)),
            ...readNotifications.map(n => normalizeNotification(n, true))
          ];

          // Actualizar conteo en badge
          updateBadgeCount(unreadData.data?.count || unreadNotifications.length);

          renderNotifications(currentFilter);
        } else {
          console.error('âŒ Error al obtener notificaciones');
          showNoNotifications();
        }
      } catch (error) {
        console.error('âŒ Error:', error);
        showNoNotifications();
      }
    }

    // Normalizar formato de notificaciÃ³n
    function firstNonEmpty(...values) {
      for (const value of values) {
        if (value === null || value === undefined) continue;
        if (Array.isArray(value)) {
          const first = value.find((item) => item !== null && item !== undefined && String(item).trim().length > 0);
          if (first !== undefined) return String(first).trim();
          continue;
        }
        if (typeof value === 'object') continue;
        const text = String(value).trim();
        if (text.length > 0) return text;
      }
      return '';
    }

    function asObject(value) {
      if (typeof value === 'string') {
        try {
          const parsed = JSON.parse(value);
          if (parsed && typeof parsed === 'object' && !Array.isArray(parsed)) return parsed;
        } catch (_) {}
      }
      return value && typeof value === 'object' && !Array.isArray(value) ? value : {};
    }

    function escapeHtml(value) {
      return String(value ?? '')
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#039;');
    }

    function collectExtraFields(payload, rootNotif = {}) {
      const data = asObject(payload);
      const root = asObject(rootNotif);
      const nested = [
        asObject(root.data),
        asObject(root.payload),
        asObject(root.metadata),
        asObject(root.meta),
        asObject(root.extra),
        asObject(root.extra_info),
        asObject(root.additional_data),
        asObject(root.details),
        asObject(root.context),
        asObject(data.data),
        asObject(data.metadata),
        asObject(data.meta),
        asObject(data.extra),
        asObject(data.extra_info),
        asObject(data.additional_data),
        asObject(data.details),
        asObject(data.payload),
        asObject(data.context)
      ];

      const allSources = [root, data, ...nested];

      const pick = (...keys) => {
        for (const source of allSources) {
          for (const key of keys) {
            const value = source[key];
            const normalized = firstNonEmpty(value);
            if (normalized) return normalized;
          }
        }
        return '';
      };

      const amountValue = firstNonEmpty(
        root.amount,
        root.total,
        root.total_amount,
        root.monto,
        data.amount,
        data.total,
        data.total_amount,
        data.monto,
        ...nested.map(n => n.amount),
        ...nested.map(n => n.total),
        ...nested.map(n => n.total_amount),
        ...nested.map(n => n.monto)
      );

      const amount = amountValue && !Number.isNaN(Number(amountValue)) ? Number(amountValue) : null;

      const info = {
        amount,
        conceptName: pick('concept_name', 'concept', 'concepto', 'title_concept'),
        reference: pick('reference', 'folio', 'payment_reference', 'payment_intent_id', 'transaction_id'),
        status: pick('status', 'payment_status', 'estado'),
        dueDate: pick('due_date', 'fecha_limite', 'deadline', 'limit_date'),
        period: pick('period', 'periodo', 'semester', 'semestre', 'month', 'mes'),
        studentName: pick('student_name', 'alumno', 'student', 'user_name'),
        group: pick('group', 'grupo', 'classroom'),
        originalType: firstNonEmpty(root.type, payload?.type)
      };

      info.extraItems = [
        { label: 'Concepto', value: info.conceptName },
        { label: 'Referencia', value: info.reference },
        { label: 'Estado', value: info.status },
        { label: 'Vence', value: info.dueDate },
        { label: 'Periodo', value: info.period },
        { label: 'Alumno', value: info.studentName },
        { label: 'Grupo', value: info.group }
      ].filter(item => item.value);

      if (info.extraItems.length === 0) {
        const genericIgnore = new Set([
          'id', 'title', 'subject', 'heading', 'message', 'body', 'description', 'type',
          'created_at', 'updated_at', 'read_at', 'notifiable_id', 'notifiable_type'
        ]);

        const genericLabels = {
          amount: 'Monto',
          total: 'Total',
          total_amount: 'Total',
          monto: 'Monto',
          details: 'Detalles',
          detail: 'Detalle',
          description: 'DescripciÃ³n',
          subject: 'Asunto',
          category: 'CategorÃ­a',
          source: 'Origen',
          deadline: 'Vence',
          created_at: 'Creado',
          updated_at: 'Actualizado',
          type: 'Tipo',
          concept_name: 'Concepto',
          concept: 'Concepto',
          concepto: 'Concepto',
          reference: 'Referencia',
          folio: 'Folio',
          status: 'Estado',
          due_date: 'Vence',
          period: 'Periodo',
          student_name: 'Alumno',
          group: 'Grupo'
        };

        const genericItems = [];
        for (const source of allSources) {
          for (const [key, rawValue] of Object.entries(source)) {
            if (genericIgnore.has(key)) continue;
            if (rawValue === null || rawValue === undefined) continue;
            if (typeof rawValue === 'object') continue;
            const value = String(rawValue).trim();
            if (!value) continue;
            genericItems.push({
              label: genericLabels[key] || key.replace(/_/g, ' '),
              value
            });
          }
        }

        const dedup = [];
        const seen = new Set();
        for (const item of genericItems) {
          const sig = `${item.label}:${item.value}`;
          if (seen.has(sig)) continue;
          seen.add(sig);
          dedup.push(item);
          if (dedup.length >= 6) break;
        }
        info.extraItems = dedup;
      }

      return info;
    }

    function normalizeNotification(notif, isRead) {
      const data = asObject(notif.data);
      const type = getNotificationType(notif.type, data.type);
      const extras = collectExtraFields(data, notif);
      
      return {
        id: notif.id,
        type: type.key,
        title: firstNonEmpty(data.title, data.subject, data.heading, notif.title) || 'NotificaciÃ³n',
        message: firstNonEmpty(data.message, data.body, data.description, notif.message),
        date: new Date(notif.created_at),
        read: isRead,
        icon: type.icon,
        color: type.color,
        metadata: {
          concept_id: firstNonEmpty(data.concept_id, data.conceptId),
          concept_name: extras.conceptName,
          amount: extras.amount,
          reference: extras.reference,
          status: extras.status,
          due_date: extras.dueDate,
          period: extras.period,
          student_name: extras.studentName,
          group: extras.group,
          extra_items: extras.extraItems,
          original_type: extras.originalType
        }
      };
    }

    // Determinar tipo de notificaciÃ³n
    function getNotificationType(classType, dataType) {
      const className = String(classType || '');
      const dataKind = String(dataType || '').toLowerCase();

      if (className.includes('Payment') || dataKind.includes('payment') || dataKind.includes('pago')) {
        return { key: 'payment', icon: 'ðŸ’°', color: 'emerald' };
      }
      if (className.includes('Academic') || dataKind.includes('academic') || dataKind.includes('academ')) {
        return { key: 'academic', icon: 'ðŸ“š', color: 'blue' };
      }
      if (className.includes('Administrative') || dataKind.includes('administrative') || dataKind.includes('admin')) {
        return { key: 'administrative', icon: 'ðŸ“‹', color: 'purple' };
      }
      return { key: 'general', icon: 'ðŸ“¢', color: 'pink' };
    }

    // Marcar notificaciÃ³n como leÃ­da
    async function markAsRead(notificationId) {
      const token = getToken();
      if (!token) return;

      try {
        const response = await fetch(`${API_BASE}/notifications/mark-as-read/${notificationId}`, {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json'
          }
        });

        if (response.ok) {
          const result = await response.json();
          console.log('âœ… NotificaciÃ³n marcada como leÃ­da:', notificationId);
          
          // Actualizar localmente
          const notif = allNotifications.find(n => n.id === notificationId);
          if (notif) {
            notif.read = true;
            
            // Actualizar badge con el unread_count del API
            updateBadgeCount(result.data?.unread_count || 0);
            
            // Re-renderizar
            renderNotifications(currentFilter);
          }
        } else if (response.status === 404) {
          console.error('âŒ NotificaciÃ³n no encontrada');
        } else {
          console.error('âŒ Error al marcar como leÃ­da');
        }
      } catch (error) {
        console.error('âŒ Error:', error);
      }
    }

    // Marcar todas como leÃ­das
    async function markAllAsRead() {
      const token = getToken();
      if (!token) return;

      try {
        const response = await fetch(`${API_BASE}/notifications/mark-as-read`, {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json'
          }
        });

        if (response.ok) {
          const result = await response.json();
          console.log('âœ… Todas las notificaciones marcadas como leÃ­das');
          
          // Actualizar localmente todas las notificaciones como leÃ­das
          allNotifications.forEach(n => n.read = true);
          
          // Actualizar badge con el unread_count del API (deberÃ­a ser 0)
          updateBadgeCount(result.data?.unread_count || 0);
          
          // Re-renderizar
          renderNotifications(currentFilter);
        } else {
          console.error('âŒ Error al marcar todas como leÃ­das');
        }
      } catch (error) {
        console.error('âŒ Error:', error);
      }
    }

    // Eliminar notificaciÃ³n
    async function deleteNotification(notificationId) {
      const token = getToken();
      if (!token) return;

      if (!confirm('Â¿EstÃ¡s seguro de que quieres eliminar esta notificaciÃ³n?')) {
        return;
      }

      try {
        const response = await fetch(`${API_BASE}/notifications/${notificationId}`, {
          method: 'DELETE',
          headers: {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json'
          }
        });

        if (response.ok) {
          console.log('âœ… NotificaciÃ³n eliminada:', notificationId);
          
          // Eliminar localmente
          allNotifications = allNotifications.filter(n => n.id !== notificationId);
          
          // Re-renderizar
          renderNotifications(currentFilter);
          
          // Recargar para actualizar conteo
          await fetchNotifications();
        } else if (response.status === 404) {
          console.error('âŒ NotificaciÃ³n no encontrada');
        } else {
          console.error('âŒ Error al eliminar notificaciÃ³n');
        }
      } catch (error) {
        console.error('âŒ Error:', error);
      }
    }

    // Actualizar badge en sidebar
    function updateBadgeCount(count) {
      const badge = document.getElementById('notif-badge');
      if (badge) {
        if (count > 0) {
          badge.textContent = count > 99 ? '99+' : count;
          badge.classList.remove('hidden');
        } else {
          badge.classList.add('hidden');
        }
      }

      // Guardar en localStorage para el layout
      localStorage.setItem('unread_notifications_count', count);
    }

    // Formato de fecha relativa
    function formatRelativeTime(date) {
      const now = new Date();
      const diff = now - date;
      const seconds = Math.floor(diff / 1000);
      const minutes = Math.floor(seconds / 60);
      const hours = Math.floor(minutes / 60);
      const days = Math.floor(hours / 24);

      if (days > 0) return `Hace ${days} dÃ­a${days > 1 ? 's' : ''}`;
      if (hours > 0) return `Hace ${hours} hora${hours > 1 ? 's' : ''}`;
      if (minutes > 0) return `Hace ${minutes} minuto${minutes > 1 ? 's' : ''}`;
      return 'Justo ahora';
    }

    // Obtener color segÃºn tipo
    function getColorClasses(color, read) {
      const opacity = read ? '50' : '100';
      const colors = {
        emerald: { bg: `bg-emerald-${opacity}`, border: 'border-emerald-300', text: 'text-emerald-700' },
        blue: { bg: `bg-blue-${opacity}`, border: 'border-blue-300', text: 'text-blue-700' },
        amber: { bg: `bg-amber-${opacity}`, border: 'border-amber-300', text: 'text-amber-700' },
        purple: { bg: `bg-purple-${opacity}`, border: 'border-purple-300', text: 'text-purple-700' },
        pink: { bg: `bg-pink-${opacity}`, border: 'border-pink-300', text: 'text-pink-700' },
        red: { bg: `bg-red-${opacity}`, border: 'border-red-300', text: 'text-red-700' }
      };
      return colors[color] || colors.blue;
    }

    // Renderizar notificaciones
    function renderNotifications(filter = 'all') {
      const container = document.getElementById('notifications-container');
      const noNotifications = document.getElementById('no-notifications');
      
      let filtered = filter === 'all' 
        ? allNotifications 
        : allNotifications.filter(n => n.type === filter);

      if (filtered.length === 0) {
        container.innerHTML = '';
        noNotifications.classList.remove('hidden');
        return;
      }

      noNotifications.classList.add('hidden');
      
      container.innerHTML = filtered.map(notif => {
        const colors = getColorClasses(notif.color, notif.read);
        const readBadge = notif.read ? '' : `
          <span class="absolute top-4 right-4 w-3 h-3 bg-[#86efad] rounded-full animate-pulse"></span>
        `;
        const amountBlock = notif.metadata.amount !== null && !Number.isNaN(Number(notif.metadata.amount))
          ? `<div class="text-xs font-bold text-emerald-600">ðŸ’µ $${Number(notif.metadata.amount).toFixed(2)}</div>`
          : '';
        const extraInfoBlock = Array.isArray(notif.metadata.extra_items) && notif.metadata.extra_items.length
          ? `
            <div class="mt-3 notification-details">
              <button class="toggle-details-btn inline-flex items-center gap-2 text-xs font-bold text-[#2e594d] hover:text-[#86efad] transition-colors" data-id="${notif.id}" aria-expanded="false">
                <span>Detalles</span>
                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 details-chevron transition-transform duration-200" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" />
                </svg>
              </button>
              <div class="details-content hidden mt-2 grid sm:grid-cols-2 lg:grid-cols-3 gap-2">
                ${notif.metadata.extra_items.map(item => {
                  const normalizedLabel = String(item?.label || '').toLowerCase();
                  const rawValue = String(item?.value || '');
                  const isLongDetail = normalizedLabel.includes('detalle') || normalizedLabel.includes('resumen') || rawValue.length > 140 || rawValue.includes('\n') || rawValue.includes('<pre>');
                  const cardSpan = isLongDetail ? 'sm:col-span-2 lg:col-span-3' : '';
                  return `
                  <div class="bg-slate-50 border border-slate-200 rounded-lg px-2.5 py-1.5 ${cardSpan}">
                    <p class="text-xs font-semibold text-slate-500 uppercase tracking-wide">${escapeHtml(item.label)}</p>
                    <p class="text-xs font-medium text-slate-700 break-words whitespace-pre-wrap leading-relaxed">${escapeHtml(item.value)}</p>
                  </div>
                `;
                }).join('')}
              </div>
            </div>
          `
          : '';
        
        return `
          <div class="notification-item relative bg-white border-l-4 ${colors.border} rounded-xl p-4 sm:p-5 shadow-md hover:shadow-xl transition-all overflow-hidden ${notif.read ? 'opacity-60' : ''}" data-id="${notif.id}">
            ${readBadge}
            <button class="delete-notif-btn absolute top-2 right-2 w-6 h-6 flex items-center justify-center rounded-full bg-red-100 hover:bg-red-200 text-red-600 hover:text-red-700 transition-colors" data-id="${notif.id}" title="Eliminar notificaciÃ³n">
              <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
              </svg>
            </button>
            <div class="flex items-start gap-3 sm:gap-4 min-w-0">
              <div class="text-3xl">${notif.icon}</div>
              <div class="flex-1 min-w-0">
                <div class="mb-2 pr-6 min-w-0">
                  <div class="flex flex-col sm:flex-row sm:items-start sm:justify-between gap-1 sm:gap-2 min-w-0">
                    <h3 class="text-base sm:text-lg font-bold text-gray-900 leading-tight break-words whitespace-normal flex-1 min-w-0">${escapeHtml(notif.title)}</h3>
                    <span class="text-xs ${colors.text} font-semibold sm:shrink-0">${formatRelativeTime(notif.date)}</span>
                  </div>
                </div>
                <p class="text-sm text-gray-600 mb-2 break-words">${escapeHtml(notif.message)}</p>
                ${amountBlock}
                ${extraInfoBlock}
                <div class="flex gap-3 mt-2">
                  ${!notif.read ? `
                    <button class="mark-read-btn text-xs font-bold text-[#2e594d] hover:text-[#86efad] transition-colors" data-id="${notif.id}">
                      âœ“ Marcar como leÃ­da
                    </button>
                  ` : ''}
                </div>
              </div>
            </div>
          </div>
        `;
      }).join('');

      // Event listeners para marcar como leÃ­da
      document.querySelectorAll('.mark-read-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          const id = btn.dataset.id;
          markAsRead(id);
        });
      });

      // Event listeners para eliminar
      document.querySelectorAll('.delete-notif-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          const id = btn.dataset.id;
          deleteNotification(id);
        });
      });

      // Event listeners para mostrar/ocultar detalles
      document.querySelectorAll('.toggle-details-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          const detailsWrapper = btn.closest('.notification-details');
          if (!detailsWrapper) return;

          const detailsContent = detailsWrapper.querySelector('.details-content');
          const chevron = detailsWrapper.querySelector('.details-chevron');
          if (!detailsContent || !chevron) return;

          const isHidden = detailsContent.classList.contains('hidden');
          detailsContent.classList.toggle('hidden', !isHidden);
          chevron.classList.toggle('rotate-180', isHidden);
          btn.setAttribute('aria-expanded', isHidden ? 'true' : 'false');
        });
      });

      document.querySelectorAll('.notification-details').forEach(section => {
        section.addEventListener('click', (e) => {
          e.stopPropagation();
        });
      });

      // Click en la notificaciÃ³n completa (solo marcar como leÃ­da, no eliminar)
      document.querySelectorAll('.notification-item').forEach(item => {
        item.addEventListener('click', (e) => {
          // No hacer nada si se clickeÃ³ en el botÃ³n de eliminar
          if (e.target.closest('.delete-notif-btn')) return;
          
          const id = item.dataset.id;
          const notif = allNotifications.find(n => n.id === id);
          if (notif && !notif.read) {
            markAsRead(id);
          }
        });
      });
    }

    function showNoNotifications() {
      const container = document.getElementById('notifications-container');
      const noNotifications = document.getElementById('no-notifications');
      container.innerHTML = '';
      noNotifications.classList.remove('hidden');
    }

    // Filtros
    document.querySelectorAll('.filter-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        currentFilter = btn.dataset.filter;
        renderNotifications(currentFilter);
      });
    });

    // Marcar todas como leÃ­das
    document.getElementById('mark-all-read-btn').addEventListener('click', () => {
      markAllAsRead();
    });

    // Cargar notificaciones al iniciar
    fetchNotifications();

    // Recargar cada 30 segundos
    setInterval(fetchNotifications, 30000);
  </script>

  <style>
    .filter-btn {
      background: #f3f4f6;
      color: #6b7280;
      border: 2px solid transparent;
    }
    
    .filter-btn.active {
      background: #2e594d;
      color: white;
      border-color: #86efad;
      box-shadow: 0 4px 12px rgba(46, 89, 77, 0.3);
    }
    
    .filter-btn:hover {
      background: #86efad;
      color: #2e594d;
      transform: translateY(-2px);
    }
  </style>
</Layout>
